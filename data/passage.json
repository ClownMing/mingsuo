{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1645771979275423746",
        "title": "极简Next.js指南01，想学Next.js的看过来！",
        "description": "半小时学会基本的Next.js基础知识",
        "content": "#### 参考文档\n\n- https://www.freecodecamp.org/chinese/news/the-next-js-handbook/#introduction\n- https://www.nextjs.cn/docs/getting-started\n- [https://nextjs.frontendx.cn/docs/#%E7%94%9F%E6%88%90%3Chead%3E](https://nextjs.frontendx.cn/docs/#生成)\n- https://github.com/vercel/next.js\n\n\n#### 优势（相比较其他框架）\n\n- 服务端渲染\n- seo友好\n\n#### next.js基本知识\n\n- 是一个react框架\n- 一个**零配置**，**单指令的react应用工具链 （？？？需要验证）**\n- 提供了一个通用的结构，使你能够轻松地建立一个前端的 React 应用程序，并透明地为你处理服务器端的渲染。**（？？？需要验证）**\n\n#### 主要功能\n\n- Hot Code Reloading（代码热加载）\n\nNext.js 在检测到保存到磁盘的任何变化时，会重新加载页面。\n\n- Automatic Routing（自动路由）\n\n任何 URL 都被映射到文件系统中，映射到放在 pages 文件夹中的文件，你不需要任何配置（当然你有自定义选项）\n\n- Single File Components（单文件组件）\n\n使用`styled-jsx`，完全集成在同一个团队中，为组件添加样式的范围是很简单的。\n\n- Server Rendering（服务器端渲染）\n\n你可以在服务器端渲染 React 组件，然后再将 HTML 发送到客户端。\n\n- Ecosystem Compatibility（生态系统的兼容性）\n\nNext.js 与 JavaScript、Node 和 React 生态系统的其他部分配合良好。\n\n- Automatic Code Splitting（自动代码拆分）\n\n渲染页面时，只需使用它们需要的库和 JavaScript，而无需其他。Next.js 不会生成一个包含所有应用程序代码的单一 JavaScript 文件，而是将应用程序自动分解为几个不同的资源。\n\n加载一个页面只加载该特定页面所需的 JavaScript。\n\nNext.js 通过分析导入的资源来做到这一点。\n\n例如，如果你只有一个页面导入了 Axios 库，那么这个特定的页面将在打包（bundle）的时候包含该库。\n\n这可以确保你的第一个页面加载速度尽可能快，而且只有未来的页面加载（如果它们将被触发）才会向客户端发送所需的 JavaScript。\n\n有一个值得注意的例外。如果经常使用的导入程序在网站页面中至少有一半被使用，它们就会被打包到主 JavaScript 中。\n\n- Prefetching（预取）\n\n用于连接不同页面的 Link 组件支持 prefetch prop ，在后台自动预取页面资源（包括因代码分割而丢失的代码）。\n\n- Dynamic Components（动态组件）\n\n你可以动态地导入 JavaScript 模块和 React 组件。\n\n- Static Exports（静态导出）\n\n使用next export命令，Next.js 允许你从你的应用程序导出一个完全静态的网站。\n\n- TypeScript Support（支持 TypeScript）\n\nNext.js 是用 TypeScript 编写的，因此，它具有出色的 TypeScript 支持。\n\n### Next.js 学习\n\n#### 1. 新建一个next.js项目\n\n确保在安装next.js项目之前，你的环境有node.js。node,js自带npm，所有安装好node.js，我们的环境就ok了\n\n##### 安装方法： \n\n1. 使用`create-next-app`,\n2. 传统方法，手动安装和设置\n\n##### 先说使用脚手架的方法\n\n我们可以把`create-next-app`当成 `create-next-app`；或者Vue中的`create-vue`；我们直接打开终端运行`npx create-next-app`,脚手架会帮我们新建一个文件夹，并下载项目所需要的包，下载完成后，我们运行`npm run dev`，并在游览器打开`http://localhost:3000`即可看见下面页面：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/UIujXwuP-image.png)\n\n如果跟着`freeCodeCamp`学习的，可以知道我们可以下载一些额外的代码，更加快速的搭建自己的项目，命令为`npx create-next-app --example blog-starter` 其中`blog-starter`为可变的，具体可看这个仓库`https://github.com/vercel/next-learn`\n\n##### 手动创建（0->1）\n\n1. 创建一个文件夹，存放你的`next.js`应用程序\n2. `npm init -y`初始化一个新的node.js项目，`-y`是 `-yes`，告诉`npm`项目使用默认配置，生成一个模板文件`package.json`。\n3. 安装`Next` 和 `React`：`npm install next react react-dom` (如果你还没有喜欢的编辑器，我推荐使用VSCode, 对新人友好，简单，WebStorm也是很好的选择)\n4. 修改脚本(`scripts`) 部分\n\n```javascript\n\"scripts\": {\n  \"dev\": \"next\",\n  \"build\": \"next build\",\n  \"start\": \"next start\"\n}\n// \"dev\": \"next -p 3001\", 这样写，我们的项目启动端口号就是3001\n```\n\n1. 创建一个`pages`文件夹，并添加一个`index.js`文件。\n\n```javascript\nconst Index = () => (\n  <div>\n    <h1>Home page</h1>\n  </div>\n)\n\nexport default Index\n```\n\n1. 使用终端，运行 npm run dev 来启动 Next 开发服务器\n\n#### 2. 验证next.js是SSR的工作方式\n\n**SSR:( 服务器端渲染**`**server side rendered**` **)** ,是一个做门户网站非常好的特性，因为：如果我们使用 Next.js 创建一个网站，网站页面会在服务器上渲染，而服务器会将 HTML 传递给浏览器，具体的优点有三个：\n\n- 客户端不需要实例化 React 来渲染，这使得**网站对你的用户来说更快**。\n- **搜索引擎会对页面进行索引**，而不需要运行客户端的 JavaScript。谷歌开始解决这个问题（客户端渲染），但公开承认是一个较慢的过程（如果你想获得好的排名，你应该尽可能地帮助谷歌）。\n- **你可以有社交媒体元标签**，对添加预览图片，为你在 Facebook、Twitter 上分享的任何页面定制标题和描述都很有用。\n\n验证的方式非常简单：我们右键我们的next.js应用，查看网站源代码，我们可以看到下面这些代码\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <style data-next-hide-fouc=\"true\">\n    body {\n      display: none\n    }\n  </style><noscript data-next-hide-fouc=\"true\">\n    <style>\n      body {\n        display: block\n      }\n    </style>\n  </noscript>\n  <meta charSet=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width\" />\n  <title>Create Next App</title>\n  <meta name=\"description\" content=\"Generated by create next app\" />\n  <link rel=\"icon\" href=\"/favicon.ico\" />\n  <meta name=\"next-head-count\" content=\"5\" /><noscript data-n-css=\"\"></noscript>\n  <script defer=\"\" nomodule=\"\" src=\"/_next/static/chunks/polyfills.js?ts=1668608244862\"></script>\n  <script src=\"/_next/static/chunks/webpack.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/main.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/pages/_app.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/pages/index.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/development/_buildManifest.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/development/_ssgManifest.js?ts=1668608244862\" defer=\"\"></script><noscript\n    id=\"__next_css__DO_NOT_USE__\"></noscript>\n</head>\n\n<body>\n  <div id=\"__next\">\n    <div class=\"Home_container__bCOhY\">\n      <main class=\"Home_main__nLjiQ\">\n        <h1 class=\"Home_title__T09hD\">Welcome to <a href=\"https://nextjs.org\">Next.js!</a></h1>\n        <p class=\"Home_description__41Owk\">Get started by editing\n          <!-- --> <code class=\"Home_code__suPER\">pages/index.tsx</code>\n        </p>\n        <div class=\"Home_grid__GxQ85\"><a href=\"https://nextjs.org/docs\" class=\"Home_card___LpL1\">\n            <h2>Documentation →</h2>\n            <p>Find in-depth information about Next.js features and API.</p>\n          </a><a href=\"https://nextjs.org/learn\" class=\"Home_card___LpL1\">\n            <h2>Learn →</h2>\n            <p>Learn about Next.js in an interactive course with quizzes!</p>\n          </a><a href=\"https://github.com/vercel/next.js/tree/canary/examples\" class=\"Home_card___LpL1\">\n            <h2>Examples →</h2>\n            <p>Discover and deploy boilerplate example Next.js projects.</p>\n          </a><a\n            href=\"https://vercel.com/new?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app\"\n            target=\"_blank\" rel=\"noopener noreferrer\" class=\"Home_card___LpL1\">\n            <h2>Deploy →</h2>\n            <p>Instantly deploy your Next.js site to a public URL with Vercel.</p>\n          </a></div>\n      </main>\n      <footer class=\"Home_footer____T7K\"><a\n          href=\"https://vercel.com?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app\"\n          target=\"_blank\" rel=\"noopener noreferrer\">Powered by\n          <!-- --> <span class=\"Home_logo__27_tb\"><img alt=\"Vercel Logo\" srcSet=\"/vercel.svg 1x, /vercel.svg 2x\"\n              src=\"/vercel.svg\" width=\"72\" height=\"16\" decoding=\"async\" data-nimg=\"1\" loading=\"lazy\"\n              style=\"color:transparent\" /></span>\n        </a></footer>\n    </div>\n  </div>\n  <script src=\"/_next/static/chunks/react-refresh.js?ts=1668608244862\"></script>\n  <script id=\"__NEXT_DATA__\"\n    type=\"application/json\">{\"props\":{\"pageProps\":{}},\"page\":\"/\",\"query\":{},\"buildId\":\"development\",\"nextExport\":true,\"autoExport\":true,\"isFallback\":false,\"scriptLoader\":[]}</script>\n</body>\n\n</html>\n```\n\n可以看到这是一个html网页\n\n#### 3. 安装 React DevTools\n\nNext.js 是基于 React 的，所以我们绝对需要安装一个非常有用的工具（如果你还没有），那就是 React 开发者工具（React Developer Tools\n\n安装成功之后，我们打开`F12`可以看见新增了两个\n\n![img](https://cdn.nlark.com/yuque/0/2022/png/21765913/1668608585453-1c99947b-7c5b-4e52-a100-da13fe8b55fa.png)\n\n它的具体使用可参考[手册](https://www.freecodecamp.org/chinese/news/the-next-js-handbook/#the-app-bundles)的对应部分讲解\n\n#### 4. 给网站添加第二页\n\n非常简单，\n\n1. 在`pages`目录下，新建一个文件，要以`.js .ts .tsx`等结尾，文件名就是路由名称\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/X1I8iTrg-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/kEljTksg-image.png)\n\n- 如果你正在做这一步，你会惊奇的发现，它是热更新的，\n- 如果你喜欢专研，当你查看源代码，你会发现它有类似这种`/_next/static/chunks/pages/new.js?ts=1668609323024`,但是没有主页的`/_next/static/chunks/pages/index.js?ts=1668609366382`这也就验证了，`next.js`的自动代码分包的能力 \uD83D\uDC4D\uD83D\uDC4D\uD83D\uDC4D\n\n#### 5. 链接两个页面\n\n我们可以使用最简单的a标签实现\n\n```html\n<a href=\"/blog\">Blog</a>\n```\n\n但是，我们不能这样做，因为你使用了`next.js`,你可以有更好的方式来实现它\n\n使用 Next 的主要好处之一是，一旦一个页面被加载，由于客户端的渲染，过渡到其他页面的速度非常快。\n\n当我们使用a标签，第一次加载时候，我们得到了所有加载页面的bundles，当我们点击链接，我们又从服务器得到了**所有的JavaScript**，**这样是不合理的**，因为我们已经得到了所有的JavaScript，我们只需要新进来的这个页面的bundle,\n\n**为了解决这个问题**，`next.js`提供了一个组件叫，`Link`,我们现在体验一下，\n\n```javascript\nimport Link from 'next/link' // 先导入它\n```\n\n然后我们把它当做我们的`a`标签使用，像这样 \uD83D\uDC47 \uD83D\uDC47 \n\n```javascript\n<Link href=\"/\">go to home</Link>\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/EuYDDSir-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/WPeG0eeU-image.png)\n\n如果你正在做，你会发现，现在只会再请求一个`new.js`,如果你在这个页面有一个返回按钮，你会发现它不会再次请求任何文件，而且页面的加载速度比以前快了很多，这就是客户端渲染的作用。\n\n#### 6. 路由与动态内容\n\n博客是`next.js`很好的一个使用场景，在博客中有一个非常常见的页面，就是博客文章，文章的样式是固定的，内容是不同的，通过一个动态的URL来判断，不同的URL对应着不同的内容，内容可能取自数据库，也可能是Markdown文档**，Next.js 可以根据一个\\**dynamic URL(动态 URL)\\**来提供动态内容。**具体实现 \uD83D\uDC47 \uD83D\uDC47 \n\n1. 通过使用`[]`语法创建一个动态页面来创建一个动态 URL。\n2. 如何创建？我们添加一个`pages/blog/[id].js`文件。这个文件将处理`/blog/`路径下的所有动态 URL\n3. 方括号内的`[id]`意味着任何动态的东西都将被放在 **路由的查询属性（query property）**的id参数中。\n\n划重点⭐️ ⭐️ ⭐️ \n\n这里可能有帅气的小伙伴会问，什么是路由？？\n\n- 路由(router)是 Next.js 提供的一个库。\n- 我们从 next/router 导入它`import { useRouter } from 'next/router'`\n- 我们有了useRouter，我们就用useRouter来实例化路由对象:`const router = useRouter()`\n- 有了这个路由对象，我们就可以从中提取信息\n- 我们可以通过访问`router.query.id`来获得`[id].js`文件中 URL 的动态部分。\n- 动态部分也可以只是 URL 的一部分，如`post-[id].js`。\n- 让我们`code a demo`\n\n```javascript\n// 创建文件pages/blog/[id].js\nimport { useRouter } from 'next/router'\n// import '../blog/blog'\nexport default () => {\n  const router = useRouter()\n  return (\n    <div className='box'>\n      <h1>Blog Context</h1>\n      <h3>Time: 2022-11-20</h3>\n      <div>\n        <span>Post id: &nbsp;&nbsp;&nbsp;{router.query.id}</span>\n        <br />\n        今天也有认真的学习，认真的生活，嘿嘿！！！<br />\n        \uD83D\uDE06 \uD83D\uDE0A \uD83D\uDE03 \uD83D\uDE0F \uD83D\uDE0D \uD83D\uDE18 \uD83D\uDE1A \uD83D\uDE33 \uD83D\uDE0C \uD83D\uDE06 \uD83D\uDE01 \uD83D\uDE09 \uD83D\uDE1C \uD83D\uDE1D \uD83D\uDE00 \uD83D\uDE17 \uD83D\uDE19 \uD83D\uDE1B<br />\n        \uD83D\uDC99 \uD83D\uDC9C ❤️ \uD83D\uDC9A \uD83D\uDC94 \uD83D\uDC93 \uD83D\uDC97 \uD83D\uDC95 \uD83D\uDC9E \uD83D\uDC98 \uD83D\uDC96 ✨ ⭐️ \uD83C\uDF1F <br />\n        \uD83D\uDE4B \uD83D\uDC70 \uD83D\uDE4E \uD83D\uDE4D \uD83D\uDE47 \uD83D\uDC91 \uD83D\uDC86 \uD83D\uDC87 <br />\n        \uD83D\uDC2D \uD83D\uDC39 \uD83D\uDC30 \uD83D\uDC3A \uD83D\uDC38 \uD83D\uDC2F \uD83D\uDC28 \uD83D\uDC3B \uD83D\uDC37 \uD83D\uDC3D \uD83D\uDC2E<br />\n      </div>\n    </div>\n  )\n}\n```\n\n- 这样我们就可以去`http://localhost:3000/blog/test`路由,其中test可以替换为任意字符，它就是我们接收到的id\n- 那么我们就可以使用这个id作为参数，从一个帖子列表中收集帖子，例如，从一个`JSON`数据库中获取帖子数据，看下面 \uD83D\uDC47 \uD83D\uDC47 \n\n们将在项目根目录下添加一个posts.json文件\n\n```json\n{\n  \"test\": {\n    \"title\": \"test post\",\n    \"content\": \"Hey some post content\"\n  },\n  \"second\": {\n    \"title\": \"second post\",\n    \"content\": \"Hey this is the second post content\"\n  }\n}\n```\n\n现在我们可以导入它，并从id键中查找帖子:\n\n```tsx\nimport { useRouter } from 'next/router'\nimport posts from '../../posts.json'\n\nexport default () => {\n  const router = useRouter()\n\n  const post = posts[router.query.id]\n\n  return (\n    <>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </>\n  )\n}\n```\n\n我们是不是就可以根据id获取数据库（JSON对象）中对应的内容了呢？？\n\n结果是报错了\uD83D\uDC7F\uD83D\uDC7F\uD83D\uDC7F\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/eena7Ygn-image.png)\n\n为什么呢？因为在渲染过程中，当组件被**初始化**时，数据还不在那里。后面会用 **getInitialProps** 向组件提供数据。\n\n虽然解决了这个问题，但它不能实现 SSR，这既损害了用户的加载时间，也损害了 SEO 和社交分享\n\n#### 7. Prefetching\n\n我们使用Link 组件可以用来创建 2 个页面之间的链接，当你使用它时，**Next.js 会透明地为我们处理前端路由**，所以当用户点击一个链接时，前端会负责显示新的页面，而不会像通常网页那样触发新的客户/服务器请求和响应周期。\n\n而且，只要是被`Link`标签包裹的元素出现在视口（viewport）中，Next.js 就会预取(prefetch)它所指向的 URL，只要它是一个本地链接（在你的网站上），就会使应用程序对浏览者来说超级快速。但是这种行为只在生产模式下被触发，这意味着如果你用`npm run dev`运行应用程序，你必须停止它，用`npm run build`编译你的生产包，用`npm run start`运行它。\n\n**注意**： 当页面加载时，任何再折叠上方的链接都会在你的页面触发`load`事件（当页面完全加载时触发，发生在DOMContentLoaded事件之后）时开始预取（prefetch），任何不在视口（viewport）中的其他链接标签将被预取，当用户滚动到它是，它会被预取，预取在高速连接（Wifi 和 3g 以上连接）是自动的，除非浏览器发送 [Save-Data HTTP Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Save-Data)。\n\n**可以通过设置 prefetch prop 为 false来选择不预取单个 Link 实例**\n\n```javascript\n<Link href=\"/a-link\" prefetch={false}>\n  <a>A link</a>\n</Link>\n```\n\n#### 8. 使用路由器来检测活动链接\n\n在处理链接时，一个非常重要的功能是确定什么是当前的 URL，特别是给活动链接分配一个类别，这样我们就可以使它的样式与其他的不同。我们需要使用的是`next.js`提供的`next/link`\n\n#### 9. 使用 next/router\n\n我们现在已经可以使用`Link`组件声明式的处理`Next.js`中的路由跳转，有时候我们还需要捕获当前路由信息或者编程式的触发路由变化，我们可以使用`useRouter`实例，调用其`push`方法，进行路由的切换，\n\n**注意：**这是客户端的路由，所以方法应该只在面向前端的代码中使用。确保这一点的最简单方法是在useEffect() React hook 中调用，或在componentDidMount()中调用 React 有状态组件\n\n我们最常使用的有俩个API：`push()`和`preFetch()`\n\n- push()允许我们在前端以编程方式触发 URL 变化。:` router.push('/login')`\n- prefetch()允许我们以编程方式预取（prefetch）一个 URL，当我们没有自动处理预取的Link标签时很有用:`router.prefetch('/login')`\n- 也可以使用路由来监听 [路由变更事件](https://nextjs.org/docs#router-events)。\n\n#### 10 .使用 getInitialProps() 向组件提供数据\n\n还记得前面，我们动态生成帖子，初始数据没有的问题吗？？\uD83D\uDE2B\uD83D\uDE2B因为该组件需要一些前期的数据，我们试图从 JSON 文件中获取数据时；我们页面报错了\n\n如何解决报错？又如何使SSR工作于动态路由？\n\n答：我们必须为组件提供 props，使用一个名为 getInitialProps() 的特殊函数，它被附加到组件上，具体实现步骤如下\uD83D\uDC47 \uD83D\uDC47 \n\n- 首先，我们要为该组件命名，例如这样：`export default function Content (){}`\n- 然后，我们为该函数添加属性，`Post.getInitialProps = () => {}`\n- 现在，这个函数可以得到一个对象作为其参数，参数包含有几个属性，其中，就包含我们的`query`对象，也就是我们之前得到帖子ID的对象`Post.getInitialProps = ({query}) => {}`\n- 我们可以从这个函数中返回帖子：\n\n```javascript\nPost.getInitialProps = ({ query }) => {\n  return {\n    post: posts[query.id]\n  }\n}\n```\n\n- 我们这个时候可以删除`useRouter`的导入，我们可以从`getInitialProps`中获得当前路由信息\n\n**关于getInitialProps**\n\n- `getInitialProps`函数将在服务器端执行，但也会在客户端执行\n- `getInitialProps `在它收到的上下文对象(`context object `)中，除了query对象外，还得到了其他的属性\n\n- - `pathname:` URL 的 path 部分\n  - `asPath` - 浏览器中显示的实际路径（包括查询 query）的字符串\n\n如果你做过Node.js编程，你还需要知道。虽然我不知道它在说什么\uD83D\uDE1C\uD83D\uDE1C\uD83D\uDE1C\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/ynJsSe5O-image.png)\n\n#### 11. CSS\n\n选择什么CSS方案是非常重要的，它决定了我们写css代码的方式\n\n我们有很大的自由度，因为我们可以使用任何我们喜欢的库。\n\n但 Next.js 内置了[styled-jsx](https://github.com/vercel/styled-jsx)，因为那是由维护 Next.js 的人建立的一个库。\n\n使用方法非常简单，在JSX的一个片段中插入它，最小实例为\n\n```jsx\n<div className='test'>哈哈哈哈</div>\n<style jsx>{`\n  .test{\n    background: pink;\n  }\n`}</style>\n```\n\n你以为这就完了吗？还有更厉害的\n\n```jsx\nconst Index = props => (\n  <div>\n  <h1>Home page</h1>\n\n  <style jsx>{`\n    h1 {\n      font-size: ${props.size}rem;\n    }\n  `}</style>\n  </div>\n)\n<style jsx global>{`\nbody {\n  margin: 0;\n}\n`}</style>\n```\n\n但是它也有不足的地方，如果你需要引入一个外部的css文件，你必须先安装`@zeit/next-css`（已弃用）\n\n```tsx\n// 先引入依赖\nnpm install @zeit/next-css\n// 然后在项目根目录，创建一个文件next.config.ts，这种写\nimport withCSS from '@zeit/next-css'\nmodule.exports = withCSS()\n```\n\n##### 现在推荐如下使用方式\n\n参考文档：https://nextjs.org/docs/basic-features/built-in-css-support\n\n- 全局的话，需要创建.css文件写入需要的样式，然后导入到pages/_app.js中\n- 从node_modules导入样式\n\n```javascript\n// pages/_app.js\nimport 'bootstrap/dist/css/bootstrap.css'\nimport '@reach/dialog/styles.css'\nexport default function MyApp({ Component, pageProps }) {\n  return <Component {...pageProps} />\n}\n```\n\n- 对于组件（页面）级的，添加CSS方式\n\n支持使用 [name].module.css 文件命名约定的 [CSS 模块](https://github.com/css-modules/css-modules)，CSS 模块通过自动创建唯一的类名来本地限定 CSS 的范围。这允许您在不同的文件中使用相同的 CSS 类名，而不必担心冲突。此行为使 CSS 模块成为包含组件级 CSS 的理想方式。CSS 模块文件**可以导入应用程序中的任何位置**.\n\n- 也支持sass\n\n允许您使用 .scss 和 .sass 扩展名导入 Sass。您可以通过 CSS 模块和 .module.scss 扩展名使用组件级 .module.sass。但是在此之前需要安装sass：`npm install --save-dev sass`\n\nSass 支持与上面详述的内置 CSS 支持具有相同的优点和限制。\n\n**注意**：Sass 支持[两种不同的](https://sass-lang.com/documentation/syntax)语法，每种语法都有自己的扩展名。..scss扩展名要求您使用[SCSS](https://sass-lang.com/documentation/syntax#scss)语法，而.sass扩展名要求您使用[缩进语法（“Sass”）](https://sass-lang.com/documentation/syntax#the-indented-syntax).\n\n#### 12. 添加一个封装组件\n\n我们想要使用这个项目，实现我们的想法，我们会发现，会有很多页面的结构都差不多，\n\n我们可以使用组件来复用\n\n#### 13. API Routes\n\n除了创建 页面路由（page routes），也就是将页面作为网页提供给浏览器之外，Next.js 还可以创建 API 路由（API routes）。API 路由也可以像页面一样使用 **动态路由**\n\n#### 14. 在服务器端，或在客户端运行代码\n\n在你的页面组件中，你可以通过检查window属性，判断在服务器端或在客户端执行代码。\n\n```javascript\ntypeof window !== 'undefined'\n// true代表客户端；false代表服务端\n```\n\n### end . conception\n\n#### 简约\n\n参考实例：\n\n- http://www.liuweibo.cn/p/206#heading-11\n- 个人介绍：https://eveningwater.github.io/my-web-projects/website/index.html\n\n#### 链接语雀文档\n\n\n\n#### 博客主页参考文章：\n\n1. https://developer.aliyun.com/article/999730\n2. https://developer.aliyun.com/article/805442#slide-1\n3. [https://raoenhui.github.io/nextjs/2018/08/31/Nextjs%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/#fetching-data-and-component-lifecycle](",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1619930914211520514/o8nyzDEv-WX20230411-205204@2x.png",
        "language": null,
        "viewNum": 4,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1619930914211520514",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-11T12:53:11.000+00:00",
        "updateTime": "2023-04-11T14:09:26.000+00:00",
        "user": {
          "id": "1619930914211520514",
          "planetCode": "1012",
          "userName": "SnailRun",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/aRneVaen8XSWOILibfkW5SHicYZia2oDxA8zKUtnzLRVFbwiclEK8f80QMRk3kviawzL8gTWk4MgA0P0VeF1r0O0upg/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 3,
          "followStatus": null,
          "vipExpireTime": "2024-02-05T23:06:53.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-30T05:30:01.000+00:00",
          "updateTime": "2023-04-11T12:42:03.000+00:00"
        },
        "tags": [
          "文章",
          "前端",
          "React",
          "笔记"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1645412392449921025",
        "title": "浅谈GPT镜像站点构建",
        "description": null,
        "content": "\n\n## 使用API的好处\n\n现在网上越来越多的镜像网站，其实大多都是通过使用[openAI API](https://platform.openai.com/docs/api-reference/chat/create)的GPT3.5模型，18USD免费额度方式部署，通过API的方式访问速度会更快，回复也更快，字数限制也是可控的，比访问官网更加稳定。\n\n其实很多镜像网站使用的也是在github上面开源的，start数较多的项目，像[https://chatbot.theb.ai/](https://chatbot.theb.ai/) 等镜像站点也都是使用的 [chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web) 开源项目。鱼皮专门分享了一期如何在[github中找项目](https://www.bilibili.com/video/BV1Ki4y1T7Cu/?spm_id_from=333.337.search-card.all.click)，可以帮助我们更加高效找到有用项目\n\n## 本地镜像部署\n\n目前市面上有很多人部署了镜像站点，但是本身是有一定免费额度的，况且GPT4模型可是20刀每月，应该没有这么多慈善家共享出来吧，那么选择部署3.5模型，知识库在2021年也够个人使用了。\n\n项目地址直接用 [chatgpt-web](https://github.com/Chanzhaoyu/chatgpt-web)，文档写的很详细，按着步骤走基本就能正常跑项目，注意次项目是前后端分离项目，也就是你需要启用前端和后端两个服务，进入service文件夹就可以启动后端\n\n重点就是配置env环境变量，只要有了GPT账号就变得简单了：\n\n```js\n// OpenAI API Key - https://platform.openai.com/overview ，请使用自己的KEY\nOPENAI_API_KEY=sk-rrcD2Szetumo22Ehc\n\n// change this to an `accessToken` extracted from the ChatGPT site's `https://chat.openai.com/api/auth/session` response\nOPENAI_ACCESS_TOKEN=\n\n// OpenAI API Base URL - https://api.openai.com\nOPENAI_API_BASE_URL=\n\n// OpenAI API Model - https://platform.openai.com/docs/models\nOPENAI_API_MODEL=\n\n// set `true` to disable OpenAI API debug log\nOPENAI_API_DISABLE_DEBUG=\n\n// Reverse Proxy\nAPI_REVERSE_PROXY=https://bypass.churchless.tech/api/conversation\n\n// timeout\nTIMEOUT_MS=100000\n\n// Rate Limit\nMAX_REQUEST_PER_HOUR=\n\n// Secret key\nAUTH_SECRET_KEY=\n\n// Socks Proxy Host\nSOCKS_PROXY_HOST=\n\n// Socks Proxy Port\nSOCKS_PROXY_PORT=\n\n// Socks Proxy Username\nSOCKS_PROXY_USERNAME=\n\n// Socks Proxy Password\nSOCKS_PROXY_PASSWORD=\n\n// HTTPS PROXY | 我使用的Clash，代理端口默认是7890，所以要看你本地代理端口\nHTTPS_PROXY=http://127.0.0.1:7890\n```\n\n如果正确使用了KEY，那么本地就可以访问了。\n\n次项目最重要的应该就是后端接口这一部分，因为前端可以直接在云服务器上部署，但是后端在国内基本是直接部署不了的，需要你像本地一样，使用代理才可以访问。\n\n亦或者使用国外服务器部署，我ping过一些镜像网站，基本公网IP都是在国外.\n\n\n![1.png](https://pic.code-nav.cn/post_picture/1621094259987947521/eex0Aq9f-1.png)\n\n![2.png](https://pic.code-nav.cn/post_picture/1621094259987947521/KD6mroZR-2.png)\n\n所以我就没有选择部署公网了，但是为了使用方便我把前端部署出来了，只需要填写API后端地址就可以在线访问啦！！！\n\n\n![3.png](https://pic.code-nav.cn/post_picture/1621094259987947521/KyIAGJM6-3.png)\n\n## 本地持久化开启服务\n\n当有了前端，没有后端是访问不了的，所以我用了最朴素的方式，就是当我每次打开电脑后就自动开启service服务，那么我就随时可以在本地使用镜像API了，偶尔我还能蹭到别人的后端，因为很多用户用了开源项目就没有修改接口的。\n\n当我们本地可以正常使用的时候，我们只需要做到开机就自动启动服务就好了，我选择了使用`pm2`进行项目守护进程。\n\n在service下进行如下命令：\n\n```bash\n# 全局安装\nnpm install pm2 -g\n# 不用后卸载\nnpm uninstall pm2 -g\n# 如果是linux就可以直接使用\npm2 start npm --name \"my-app-name\" -- start\n# 显然我使用的是windows，所以需要使用下面服务\nnpm install -g pm2-windows-service\n\n# 后端项目进行打包\nnpm run build\n# 后端根目录新建startscript.js ，新增如下内容\nconst cmd = require('node-cmd')\ncmd.run('npm run  prod')\n# 安装node-cmd依赖\nnpm install node-cmd --save\n\n# 安装window服务进程\npm2-service-install -n\n# 使用pm2守护进程\npm2 start startscript.js --name \"my-app-name\" \n```\n\n![4.png](https://pic.code-nav.cn/post_picture/1621094259987947521/k0hRvSAp-4.png)\n\n成功后就可以本地访问了，并且可以通过服务去开启或者关闭进程，不需要每次打开在本地跑项目了！！！\n\n有一点不明白，就是我如果本地直接运行后端就需要开启VPN代理才能访问接口，但是使用了持久化后我关闭了代理，也能够访问~~",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1621094259987947521/bRK7rdha-3.png",
        "language": null,
        "viewNum": 42,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1621094259987947521",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-10T13:04:19.000+00:00",
        "updateTime": "2023-04-11T14:08:17.000+00:00",
        "user": {
          "id": "1621094259987947521",
          "planetCode": "9263",
          "userName": "帅气的木木",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1621094259987947521/Zz4fuDXN-QQ图片20221118113213.jpg",
          "gender": 1,
          "userProfile": "前端CV工程师",
          "userRole": "vip",
          "interests": [
            "资源"
          ],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 999999999,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 5,
          "coin": 20,
          "followeeNum": 0,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-19T23:00:59.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-02T10:32:44.000+00:00",
          "updateTime": "2023-03-23T07:40:52.000+00:00"
        },
        "tags": [
          "文章",
          "ChatGPT",
          "前端"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1644305295544995842",
        "title": "ThreadLocal：听说你很熟悉我？",
        "description": "对于 ThreadLocal 常见知识点的源码分析",
        "content": "> 基于 JDK1.8\n# ThreadLocal\n`ThreadLocal` 可以用于创建线程本地变量，每个线程使用 `ThreadLocal` 都会拥有自己对该变量的副本，即每个线程都可以独立地改变其副本的值，而不会影响其他线程的副本。\n\n## 数据结构\n`ThreadLocal` 其实就是由内部实现的 `ThreadLocalMap` 组成的，`ThreadLocalMap`  是以 `ThreadLocal` 的**弱引用**作为 `key` ，`value` 为代码中放入的值，每个线程在往 `ThreadLocal` 里放值的时候，都会往自己的 `ThreadLocalMap` 里存，读也是以 `ThreadLocal` 作为引用，在自己的 `map` 里找对应的 `key` ，从而实现了线程隔离。\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1d20c633ea342d8a052d90ce29cc0eb~tplv-k3u1fbpfcp-watermark.image?)\n\n## ThreadLocalMap\n### 数据结构\nThreadLocalMap 底层就是由 Entry 数组构成\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\n\n<p align=center><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9dcea993fd7456bb837f71f9ed5739e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\"  /></p>\n\n### ThreadLocalMap.set() 原理解析\n> 源码\n````java\nprivate void set(ThreadLocal<?> key, Object value) {\n    // Entry数组\n    Entry[] tab = table;\n    int len = tab.length;\n    // 获取当前key 的索引位置\n    int i = key.threadLocalHashCode & (len-1);\n    // 以当前 key 对应的 Entry 为起点，遍历 Entry 数组\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        // 当前 Entry 的 key 等于插入值的 key\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        // 当前 Entry 的 key 为 null\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    // 插入元素\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    // 进行启发式清理工作，清除 key 为 null 的数据\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n````\n- 将 `key` 的 `HashCode` 与 `Entry` 数组的长度减一相与获取 `key` 对应的索引位置\n- 根据索引位置获取 `key` 对应的 `Entry`，以该 `Entry` 为起点遍历 `Entry` 数组\n    - 如果当前 `Entry` 为 `null` ，那么直接创建一个新的 `Entry` 插入\n    - 如果当前的 `Entry` 不为 `null`\n        - 如果当前 `Entry` 的 `key` 等于插入值的 `key` ，那么就会替换当前 `Entry` 的 `value` ，然后结束方法。\n        - 如果当前 `Entry` 的 `key` 为 `null` ，说明 `Entry` 是过期数据，执行 `replaceStaleEntry` 方法来替换过期的数据，然后结束方法。\n        - 如果以上两种情况都不符合那么就会获取到下一个 `Entry` 继续判断\n\n- 增加 `Entry` 数组的长度\n- 调用 `cleanSomeSlots` 方法进行启发式清理工作，清理数组中  `Entry` 的 key 为 `null` 的数据，如果 `cleanSomeSlots` 方法未清理任何数据，且当前数组的长度超过了阈值，那么就会调用 `rehash` 方法进行扩容\n\n### ThreadLocalMap.replaceStaleEntry() 原理解析\n> 源码\n\n```java\nprivate void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                               int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    Entry e;\n    // 待插入元素对应的索引位置\n    int slotToExpunge = staleSlot;\n    // 从待插入元素对应的索引位置开始向前迭代，\n    for (int i = prevIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = prevIndex(i, len))\n        if (e.get() == null)\n            slotToExpunge = i;\n    // 从待插入元素的索引位置 staleSlot 开始向后迭代\n    for (int i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // key 相同\n        if (k == key) {\n            e.value = value;\n            // 互换位置\n            tab[i] = tab[staleSlot];\n            tab[staleSlot] = e;\n            // 清除过期 Entry\n            if (slotToExpunge == staleSlot)\n                slotToExpunge = i;\n            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n            return;\n        }\n        // key 为null\n        if (k == null && slotToExpunge == staleSlot)\n            slotToExpunge = i;\n    }\n    // 未找到 key相同的Entry\n    tab[staleSlot].value = null;\n    tab[staleSlot] = new Entry(key, value);\n    // 清理过期数据\n    if (slotToExpunge != staleSlot)\n        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n}\n```\n- 从插入值的索引位置 `staleSlot` 开始向前迭代，找到其他过期数据，然后更新过期数据的起始位置 `slotToExpunge`，直到 `Entry` 为 `null`。\n- 从待插入元素的索引位置 `staleSlot` 开始向后迭代\n    - 如果找到了 `key` 相同的 `Entry`  ，则将当前 `Entry` 的值设置为我们插入的值，然后将当前 `Entry` 的位置与待插入元素对应的 `Entry` 位置互换，接着就根据第 1 步获取到的 `slotToExpunge` 开始过期 `Entry` 的处理，最后退出方法。\n    - 如果当前 `Entry` 的 `key` 为 `null`，且过期数据的起始位置 `slotToExpunge` 位于 `staleSlot` ，那么更新 `slotToExpunge` 为当前 `Entry` 的索引位置。\n- 如果在循环中找不到 `key` 相同的 `Entry`，就会创建新的Entry替 换 `table[stableSlot]` 的位置\n- 最后进行过期数据的清理\n\n### ThreadLocalMap.expungeStaleEntry() 原理解析\n> `int staleSlot`：空 slot 的起始位置\n```java\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    // staleSlot 即为过期 Entry 的起始位置\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n\n    Entry e;\n    int i;\n    // 从起始位置开始向后遍历\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        // key 为null\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        // key 不为 null\n        } else {\n            // 判断位置是否偏离\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                // 位置偏离重新计算位置\n                tab[i] = null;\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n- 将起始位置的 `Entry` 设置为 `null` ，并减小数组中元素的个数。\n- 从起始位置开始向后遍历 `Entry` 数组：\n    - 如果遇到 `key` 为 `null` 的 `Entry` ，那么就把当前的 `Entry` 设置为 `null` ，并且减小数组中元素的个数，然后继续往后探测。\n    - 如果碰到 `key` 不为空的 `Entry` （记作 e ），那么就会重新计算当前 `key` 对应的索引位置（记作 h ），如果与原先的索引位置（也就是当前的 i 值）发生偏离，那么就会将 `i` 对应的 `Entry` 设置为 `null` ，然后重新计算 `e` 的位置。\n    - 如果碰到空的 `slot`  则结束清理，返回空 `slot` 的位置。\n\n### ThreadLocalMap.cleanSomeSlots() 原理解析\n> `int i`：当前 Entry 的位置 <br>\n> `int n`：在插入元素时调用，这个参数代表元素的个数；在 replaceStaleEntry 中调用，这个参数代表数组的长度 。\n``` java\nprivate boolean cleanSomeSlots(int i, int n) {\n    boolean removed = false;\n    Entry[] tab = table;\n    int len = tab.length;\n    do {\n        i = nextIndex(i, len);\n        Entry e = tab[i];\n        if (e != null && e.get() == null) {\n            n = len;\n            removed = true;\n            i = expungeStaleEntry(i);\n        }\n    } while ( (n >>>= 1) != 0);\n    return removed;\n}\n```\n- 从当前 Entry 开始向后遍历，遍历 log2(n)  个元素\n- 遇到 key 为null 的Entry 则调用 expungeStaleEntry 进行清理\n\n### ThreadLocalMap 扩容机制\n在set方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值就会执行rehash()\n\n#### rehash 方法\n``` java\nprivate void rehash() {\n    expungeStaleEntries();\n\n    // 数组中的元素个数是否大于 threshold * 3/4\n    if (size >= threshold - threshold / 4)\n        resize();\n}\n```\n- 首先会调用 `expungeStaleEntries` 方法对 `Entry` 数组进行过期数据的清理\n- 然后判断当前数组中的元素个数是否大于 threshold * 3/4 ，如果大于那么就会调用 resize 方法进行扩容\n\n#### resize 方法\n\n``` java\nprivate void resize() {\n    Entry[] oldTab = table;\n    // 旧容量\n    int oldLen = oldTab.length;\n    // 新容量\n    int newLen = oldLen * 2;\n    Entry[] newTab = new Entry[newLen];\n    int count = 0;\n\n    for (Entry e : oldTab) {\n        if (e != null) {\n            ThreadLocal<?> k = e.get();\n            if (k == null) {\n                e.value = null; // Help the GC\n            } else {\n                // 重新计算hash\n                int h = k.threadLocalHashCode & (newLen - 1);\n                // hash 冲突则往后查找\n                while (newTab[h] != null)\n                    h = nextIndex(h, newLen);\n                newTab[h] = e;\n                count++;\n            }\n        }\n    }\n    // 重新计算扩容阈值\n    setThreshold(newLen);\n    size = count;\n    table = newTab;\n}\n```\n- 扩容后的 `Entry` 数组的长度变为旧容量的 `2` 倍\n- 然后去遍历旧的 `Entry` 数组，重新计算 `hash` 位置，然后放到新的 `Entry` 数组中，如果出现 `hash` 冲突则往后寻找最近的 `Entry` 为 `null` 的槽位，遍历完成之后，旧数组中所有的 `Entry` 数据都已经放入到新的 `Entry` 数组中。最后重新计算数组的扩容阈值。\n\n### ThreadLocalMap.getEntry() 原理解析\n> `ThreadLocal<?> key` ：当前key\n```java\nprivate Entry getEntry(ThreadLocal<?> key) {\n    // 获取索引\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    // 命中则直接返回\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n```\n根据 `key` 的 `hash` 获取对应的 `Entry`，如果当前 `Entry` 的 `key` 等于查找的 `key` 那就返回当前 `Entry`，否则就调用 `getEntryAfterMiss` 方法。\n\n### ThreadLocalMap.getEntryAfterMiss() 原理解析\n当 `key` 在其直接哈希槽中找不到时使用\n> `ThreadLocal<?> key` : ThreadLocal 对象 <br>\n> `int i` : ThreadLocal 对应的 hash 值 <br>\n> `Entry e` : ThreadLocal 对应的 Entry\n``` java\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n            return e;\n        if (k == null)\n            expungeStaleEntry(i);\n        else\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n```\n- 如果当前 `key` 对应的 `Entry` 不为空\n    - 判断当前 `Entry` 的 `key` 是否等于获取的 `key` ，是的话那么就返回当前的 `Entry`。\n    - 如果当前 `Entry` 的 `key` 为 `null` 那么就会调用 `expungeStaleEntry` 方法来清理，接着继续往后迭代。\n- 如果当前 `key` 对应的 `Entry` 为空就直接返回 `null`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1621700430587248641/935IjQjR-v2-fe127aac97845744e7b2124ffe16df6d_r.jpg",
        "language": null,
        "viewNum": 46,
        "thumbNum": 3,
        "favourNum": 1,
        "commentNum": 1,
        "priority": 0,
        "userId": "1621700430587248641",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-07T11:45:06.000+00:00",
        "updateTime": "2023-04-11T11:52:11.000+00:00",
        "user": {
          "id": "1621700430587248641",
          "planetCode": "17433",
          "userName": "枫",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/n7ib3uuEjhfGIvSSR9AwHFKet7RmG0HOFRFS23ibqicX3grkZc7lafFxtb4YxXUuVVKy92omwDabWTZyQiaFJXN3SA/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 1,
          "followNum": 1,
          "followStatus": null,
          "vipExpireTime": "2024-02-20T11:01:54.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-02-04T02:41:27.000+00:00",
          "updateTime": "2023-04-08T03:49:37.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1644279832026075138",
        "title": "C++ 学习路线 by 程序员鱼皮",
        "description": null,
        "content": "<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 85,
        "thumbNum": 3,
        "favourNum": 2,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-04-07T10:03:56.000+00:00",
        "updateTime": "2023-04-11T11:40:37.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 830,
          "coin": 170,
          "followeeNum": 398,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-04-11T07:53:52.000+00:00"
        },
        "tags": [
          "文章",
          "学习路线",
          "C++",
          "教程"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": true,
        "atUserVOList": null
      },
      {
        "id": "1641797333479903234",
        "title": "数据库学习路线 by 程序员鱼皮",
        "description": null,
        "content": "<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 171,
        "thumbNum": 4,
        "favourNum": 4,
        "commentNum": 1,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-03-31T13:39:22.000+00:00",
        "updateTime": "2023-04-11T13:36:49.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 830,
          "coin": 170,
          "followeeNum": 398,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-04-11T07:53:52.000+00:00"
        },
        "tags": [
          "文章",
          "学习路线",
          "数据库",
          "教程",
          "MySQL"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": true,
        "atUserVOList": null
      },
      {
        "id": "1641366118197153793",
        "title": "小程序开发学习路线 by 程序员鱼皮",
        "description": null,
        "content": "<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 99,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-03-30T09:05:52.000+00:00",
        "updateTime": "2023-04-11T05:33:38.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 830,
          "coin": 170,
          "followeeNum": 398,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-04-11T07:53:52.000+00:00"
        },
        "tags": [
          "文章",
          "学习路线",
          "小程序",
          "教程"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": true,
        "atUserVOList": null
      },
      {
        "id": "1641035880439271426",
        "title": "计算机基础学习路线 by 程序员鱼皮",
        "description": null,
        "content": "<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 118,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-03-29T11:13:37.000+00:00",
        "updateTime": "2023-04-11T09:22:47.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 830,
          "coin": 170,
          "followeeNum": 398,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-04-11T07:53:52.000+00:00"
        },
        "tags": [
          "文章",
          "学习路线",
          "计算机基础",
          "教程"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": true,
        "atUserVOList": null
      },
      {
        "id": "1640648711119892481",
        "title": "软件工程学习路线 by 程序员鱼皮",
        "description": "软件开发通用的技能",
        "content": "<a href=\"https://www.code-nav.cn/vip\" target=\"_blank\">成为会员解锁所有内容</a>",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 96,
        "thumbNum": 4,
        "favourNum": 3,
        "commentNum": 0,
        "priority": 999,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-03-28T09:35:09.000+00:00",
        "updateTime": "2023-04-11T11:09:28.000+00:00",
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 830,
          "coin": 170,
          "followeeNum": 398,
          "followNum": 5,
          "followStatus": null,
          "vipExpireTime": "2025-12-13T05:00:02.000+00:00",
          "lastLoginTime": null,
          "createTime": "2022-12-09T04:32:33.000+00:00",
          "updateTime": "2023-04-11T07:53:52.000+00:00"
        },
        "tags": [
          "文章",
          "学习路线",
          "软件开发",
          "教程"
        ],
        "fileList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": true,
        "atUserVOList": null
      }
    ],
    "total": "34",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "4"
  },
  "message": "ok"
}
